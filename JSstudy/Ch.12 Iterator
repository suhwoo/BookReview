==========================================================
iterableí•œ ê°ì²´ëŠ” for/of loopë¥¼ í†µí•´ iteratedë  ìˆ˜ ìˆë‹¤.
Iteratorì€ â€¦operator, destructuring assignmentë¡œ ì“°ì¼ ìˆ˜ ìˆë‹¤.
Map objectì—ì„œ iteratorì„ ì“¸ë•Œ [key,value] pairì´ë¼ë©´ for/of loopë¥¼ ì“°ê³  key, í˜¹ì€ valueë§Œ ê°€ì§€ê³  ì˜¤ê³  ì‹¶ë‹¤ë©´ keys(), values()ë¥¼ ì“´ë‹¤.
Array objectì—ì„œ ì“°ì´ëŠ” ëª‡ëª‡ constructorsê³¼ built-in functionsëŠ” written to accept arbitrary iterators
========í”„ë¡¤ë¡œê·¸=======
ğŸ¦‘ How Iterators work
java script iteration ì´í•´ë¥¼ ìœ„í•œ ì„¸ê°€ì§€ : 1. iterable object, 2.iterator it self 3. iteration result
iterable object : object with special iterator method that returns an iterator object.
iterator : object with next() method
iteration result : object with properties named value and done
iterable object â†’ iterator method â†’ next() â†’ done property set true
let iterable = [99]
literator = iterable[Symbol.iterator]();
for(let result = iterator.next(); ! result.done;result = iterator.next()){
  console.log(result.value);
}
ğŸ¦‘ Implementing Iterable Object
Rangeë¥¼ í†µí•´ generatorì„ ì´ìš©í•˜ì§€ ì•Šê³  iterableí•˜ê²Œ ë§Œë“¤ì–´ ë³´ì.
classë¥¼ iterableí•˜ê²Œ ë§Œë“œë ¤ë©´ Symbol.iterator methosë¥¼ êµ¬í˜„í•´ì•¼ í•œë‹¤. which return iterator object.
class Range {
  constrictor(from,to){
    this.from = from
    this.to = to
  }
  has(x){return typeof x === "number" && this.from <= x && x<= this.to}
  toString(){return '{x|${this.from} < x < ${this.to}}'}
  [Symbol.iterator](){
    let next = Math.ceil(this.from)
    let last = this.to
    return {
      next(){return (next <= last? {value:next++} : {done:true};},
      [Symbol.iterator](){return this;}
    };
  }

}

for(let x of newRange(1,10)) //23456789
when computation is requires to compute the next value, that computation can be deferred until the value is actually needed.
12.2.1 â€œClosingâ€œ an Iterator : The return value
ë¬¸ìì—´ì´ ì•„ë‹Œ íŒŒì¼ì—ì„œ ë¬¸ìë¥¼ ì½ëŠ” í”„ë¡œê·¸ë¨ì„ ìƒê°í• ë•Œ, íŒŒì¼ ì½ê¸°ê°€ ëë‚˜ë©´(nextê°€ ë§ˆì§€ë§‰ ë¬¸ìë¥¼ ê°–ë‹¤ì£¼ë©´) íŒŒì¼ì„ ë‹«ì•„ì•¼ í•œë‹¤.
ê·¸ëŸ¬ë‚˜ iteratorì´ í•­ìƒ ëê¹Œì§€ ëŒì§€ëŠ” ì•ŠëŠ”ë‹¤ (breakë‚˜ returnì— ì˜í•´ ì¤‘ë‹¨ë  ìˆ˜ ìˆë‹¤.)
ê·¸ëŸ¬ë‚˜ ëê¹Œì§€ ëŒì§€ ì•Šì„ë•Œë„ loopì—ì„œ ë¹ ì ¸ë‚˜ì™”ë‹¤ë©´ íŒŒì¼ì„ ë‹«ì•„ì•¼ í•œë‹¤. ê·¸ëŸ¬ë¯€ë¡œ iteratorì€ next()ì™€ í•¨ê»˜ return()ì„ ì œê³µí•œë‹¤.ë§Œì•½ next()ê°€ ì¤‘ë‹¨ë˜ë©´ iteratorì€ return()ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ê³  íŒŒì¼ì„ ë‹«ê³  ë©”ëª¨ë¦¬ë¥¼ í•´ì œí•œë‹¤.return()ì€ iterator reult objectë¥¼ ë°˜í™˜í•œë‹¤.
ğŸ¦‘ Generators
generatorì€ element of data structureë“¤ì´ ì•„ë‹ë•Œ ìœ ìš©í•˜ë‹¤.
generatorì„ ë§Œë“¤ë ¤ë©´ ì¼ë‹¨ generator functionì„ ì •ì˜í•´ì•¼ í•œë‹¤. ì´ functionì€ *function keywordë¥¼ ì‚¬ìš©í•¨ìœ¼ë¡œì¨ ë§Œë“¤ì–´ì§ˆ ìˆ˜ ìˆë‹¤. returnìœ¼ë¡œ generator objectë¥¼ ë°˜í™˜í•˜ëŠ”ë° ì´ objectê°€ iteratorì´ë‹¤. next() method causes generator function to run until reached yield
function* oneDigit(){
  yield 2;
  yield 3;
  yield 5;
}
let prime = oneDigit();
prime.next().value // 2
prime.next().value //3
prime.next().value // 5
prime.next().done //true
í˜¹ì€ â€¦ë¥¼ ì¨ì„œ valueë¥¼ ì¶œë ¥í•˜ê±°ë‚˜ functionì„ ìƒëµí•  ê²½ìš° *g() ì™€ ê°™ì´ ì“¸ ìˆ˜ ë„ ìˆë‹¤.
12.3.2 yield* and Recursive Generator
yieldë¥¼ í†µí•´ valueë¥¼ í•˜ë‚˜ì”© ì „ë‹¬í•˜ëŠ”ê²Œ ì•„ë‹ˆë¼ ì•„ì˜ˆ ì—¬ëŸ¬ê°œì˜ elementë¥¼ iterableí•œ objectë¡œ ë„˜ê²¨ì£¼ëŠ” ê²ƒì´ ë” ì‰¬ìš¸ê²ƒì´ë‹¤. => ES6ì—ì„œ yield* ë¥¼ í†µí•´ êµ¬í˜„ë  ìˆ˜ ìˆë‹¤.
function* sequence(...iterables){
  for(let iterable of iterables){
    yield* iterable;
  }
}
[...sequence("abc",oneDigit())]//=>["a","b","c",2,3,5]
ğŸ¦‘ Advanced Generator Feature
generatorì˜ ê¸°ë³¸ ì†ì„±ì€ ê³„ì‚°ì„ ì¼ì‹œì¤‘ì§€í•˜ê³  ì¤‘ê°„ê²°ê³¼ë¥¼ ì‚°ì¶œí•œë’¤ ë‹¤ì‹œ ê³„ì‚°ì„ ì¬ê°œí•  ìˆ˜ ìˆë‹¤.
12.4.1 The return Value of a Generator Function
ì§€ê¸ˆê¹Œì§€ ë´ì˜¨ generator í•¨ìˆ˜ëŠ” return valueê°€ ì—†ë‹¤. ê·¸ëŸ¬ë‚˜ ë‹¤ë¥¸ í•¨ìˆ˜ë“¤ ì²˜ëŸ¼ ì œë„ˆë ˆì´í„°ë„ ë¦¬í„´ê°’ì„ ë°˜í™˜í•  ìˆ˜ ìˆë‹¤. ë§Œì•½ value propertyê°€ ì •ì˜ë˜ì—ˆë‹¤ë©´ doneì€ falseë‚˜ undefinedì´ë‹¤. ê·¸ëŸ¬ë‚˜ ë¦¬í„´ê°’ì„ ë°˜í™˜í•˜ëŠ” generatorì˜ ê²½ìš°, ë§ˆì§€ë§‰ìœ¼ë¡œ ë¶€ë¥¸ nextëŠ” done, valueê°€ ë‘˜ë‹¤ definedëœ ê°’ì„ ë°˜í™˜í•œë‹¤.
12.4.2 The value of a yield Expression
ì•ì—ì„œ yieldë¥¼ statementë¡œ ë‹¤ë£¨ê³  valueë¥¼ ê°€ì§€ì§€ ì•Šì•˜ë‹¤ê³  ë‹¤ë£¨ì—ˆì§€ë§Œ ì‚¬ì‹¤ yieldëŠ” expressionì´ê³  valueë¥¼ ê°€ì§€ê³  ìˆë‹¤. yield ì—ì„œ valueëŠ” nextì˜ ë¦¬í„´ê°’ì´ ë˜ëŠ”ë°, ì—¬ê¸°ì„œ generator stop executing right in the middle of evaluating the yield expression. ë‹¤ìŒë¶€í„° next()ë¡œ ì „ë‹¬ë˜ëŠ” ê°’ì€ valueê°€ ì•„ë‹Œ yieldê°€ ëœë‹¤. generator return caller with yield, and caller pass value in to generator with next
12.4.3 The return() and throw() methods of Generator
next()ë¡œ inputì„ ì œê³µí•  ë¿ë§Œ ì•„ë‹ˆë¼ return()ê³¼ throwë¥¼ í†µí•´ generator ë‚´ë¶€ì˜ íë¦„ì„ ë³€ê²½ í•  ìˆ˜ ìˆë‹¤.
ì•ì—ì„œ ì–¸ê¸‰í–ˆë˜ê²ƒ ì²˜ëŸ¼ returnì„ customí•´ íŒŒì¼ì„ ì •ë¦¬í•˜ëŠ”ê±´ ë¶ˆê°€ëŠ¥í•˜ë‹¤. ê·¸ëŸ¬ë‚˜ try/finally ë¥¼ ì´ìš©í•´ í•„ìš”í•œ ì •ë¦¬ê°€ ë‹¤ ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ê²ƒì´ ê°€ëŠ¥í•˜ë‹¤.
next()ê°€ generatorë¡œ valueë¥¼ ì „ë‹¬í•˜ë“¯ì´ throw()ëŠ” arbitrary signalì„ generatorì—ê²Œ ë³´ë‚¸ë‹¤. throwë¥¼ ë³´ë‚´ëŠ” ê²ƒì€ generator ë‚´ë¶€ì—ì„œ exceptionì„ ë°œìƒì‹œí‚¨ë‹¤. ë§Œì•½ generator ë‚´ë¶€ì—ì„œ ì´ë¥¼ handling í•˜ëŠ” ì½”ë“œê°€ ì‘ì„±ë˜ì–´ ìˆì„ ê²½ìš°, ë¬¸ì œë¥¼ handlingí•  ìˆ˜ ìˆë‹¤.
All Iterator must have next()
Iterator that need to clean up should define return()
Any Iterator may define throw()
================================================================
Asynchronous Programming
ëŒ€ë¶€ë¶„ì˜ í”„ë¡œê·¸ë¨ì´ ì‹¤ì œí˜„ì‹¤ì„ ë°˜ì˜í•˜ê¸° ìœ„í•´ì„œëŠ” ë¹„ë™ê¸°ì‹ ì²˜ë¦¬ê°€ í•„ìš”í•˜ë‹¤ => ê²°ê³¼ê°€ ë‚˜ì˜¤ê¸°ê¹Œì§€ ê³„ì‚°ì„ pauseí•˜ë˜ì§€ í˜¹ì€ ì–´ë–¤ ì´ë²¤íŠ¸ê°€ ë°œìƒë˜ê¸°ê¹Œì§€ ê¸°ë‹¤ë¦¬ë˜ì§€
ì´ ì±•í„°ì—ì„œëŠ” ì„¸ê°€ì§€ ìš©ì–´ë¥¼ ì†Œê°œí•œë‹¤.
1.Promise
2.async await
3.for/await
ğŸ¦‘ Asynchronous Programming with Callbacks
asynchronous programming in JavaScript is done with callbacks
callback is a function that you write and then pass to some other function and then that function invoke your function when event occurs.
13.1.1 Timers
ê°€ì¥ ê°„ë‹¨í•œ ë¹„ë™ê¸°ëŠ” ëª‡ì´ˆí›„ ì‹¤í–‰ë˜ëŠ” ì½”ë“œì´ë‹¤. ì´ëŸ¬í•œ ì½”ë“  setTimeout()ì„ í†µí•´ êµ¬í˜„ë  ìˆ˜ ìˆë‹¤.
setTimeout(checkForUpdate,60000);
ì—¬ê¸°ì„œ checkForUpdatesëŠ” 60ì´ˆê°€ ì§€ë‚œë’¤(ì¡°ê±´ë§Œì¡±) ë¶ˆë¦¬ëŠ” callback í•¨ìˆ˜ì´ë‹¤.
setTimeout()ì€ callbackí•¨ìˆ˜ë¥¼ ë”± í•œë²ˆë§Œ ë¶€ë¥´ëŠ” í•¨ìˆ˜ì´ë‹¤.(with no argument)
ê·¸ëŸ¬ë¯€ë¡œ ë§Œì•½ ì‹¤ì œë¡œ updateë¥¼ í™•ì¸í•´ë³´ë ¤ë©´ ë°˜ë³µì ìœ¼ë¡œ ì‹¤í–‰ë˜ì–´ì•¼ í•  ê²ƒì´ë‹¤.
setInterval()ì„ í†µí•´ ì—¬ëŸ¬ë²ˆ ë°˜ë³µí•  ìˆ˜ ìˆë‹¤.
13.1.2 Events
Client-side JavaScriptëŠ” ìœ ì €ì˜ ë™ì‘ì„ ê¸°ë‹¤ë¦¬ê³  ë™ì‘ì— ë”°ë¼ í”„ë¡œê·¸ë¨ì´ ì‹¤í–‰ë˜ê¸° ë•Œë¬¸ì— Event-drivenì†ì„±ì„ ê°€ì§€ê³  ìˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ í´ë¦­ì„ ê¸°ë‹¤ë¦¬ê±°ë‚˜ í‚¤ë³´ë“œ inputì„ ê¸°ë‹¤ë¦¬ëŠ” ë“±ì˜ ë™ì‘ì´ ìˆë‹¤.
addEventListener()ì„ í†µí•´ ì´ë²¤íŠ¸ë¥¼ ë“£ê³  functionì„ invokeí•œë‹¤.
let okay = document.querySelector('#confirmUpdateDialog button.okay')
okay.addEventListener('click',applyUpdate);
13.1.3 Network Events
ë‹¤ë¥¸ ë¹„ë™ê¸°ì‹ JS programmingì€ network requestì´ë‹¤.
function getCurrentVersionNumber(versionCallback){
  let request = new XMLHttpRequest();
  request.open("GET","http://www.ezample.com/api/version");
  request.send();
  request.onload = function(){
    if (request.status === 200){
      let currentVersion = parseFloat(request.responseText);
      versionCallback(null,currentVersion);
    }
    else{
      versionCallback(response.statusText,null)
    }
  };
  request.onerror = request.ontimeout = function(e){
    versionCallback(e.type,null)
  }
}
ìœ„ì˜ ì½”ë“œëŠ” serverâ€™s responesê°€ ì˜¬ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ë‹¤ê°€ request.onloadì—ì„œ responesë¥¼ ë°›ìœ¼ë©´ callbackì´ invokeëœë‹¤.(JSëŠ” ë¹„ë™ê¸°ì‹ì´ë¯€ë¡œ callbackìœ¼ë¡œ responesë¥¼ ë°›ì€ ë‹¤ìŒ functionì„ invokeí•œë‹¤ ë¼ëŠ” ìˆœì„œë¥¼ ì¤€ë‹¤) ë§Œì•½ serverë¡œ ë¶€í„° errorë¥¼ ë°›ëŠ”ë‹¤ë©´ request.onerrorê°€ invokeë˜ì–´ erroríƒ€ì…ê³¼ nullì„ callbackí•´ì¤€ë‹¤.
13.1.4 Callbacks and Events in Node
server-side ì˜ JSì½”ë“œëŠ” ë¹„ë™ê¸°ì‹ì´ë‹¤. APIëŠ” eventì™€ callback functionì„ ì“´ë‹¤.
const fs = require("fs")
let options = {
  //default options
}
fs.readFile("config.json","utf-8",(err,text)=>{
  if(err){
    console.warn("Could not read config file:",err)
  }else{
    Object.assign(options,JSON,parse(text));
  }
  startProgram(options);
})
íŒŒì¼ì„ ì½ê³  callbackí•¨ìˆ˜ë¥¼ ë¶€ë¥¸ë‹¤. ë§Œì•½ fileì— errorê°€ ë‚ ì‹œ callbackì— errê°€ ì „ë‹¬ëœë‹¤
ğŸ¦‘ Promises
A Promise is an object that represents the results of an asynchronous computation.
you can only ask the Promise to call a callback function when value is ready
PromiseëŠ” callbackì—ì„œ ë¬¸ì œê°€ ë˜ì—ˆë˜ ë¶€ë¶„ì„ í•´ê²°í•´ì¤€ë‹¤.
ì²«ë²ˆì§¸ ë¬¸ì œëŠ” callbackì´ ì—¬ëŸ¬ê°œê°€ ë˜ë©´ nestedê°€ ë˜ì–´ ì½ê¸°ê°€ í˜ë“¤ì–´ ì§„ë‹¤ (ì½œë°±ì§€ì˜¥) PromiseëŠ” Promise chainì„ í†µí•´ ì´ëŸ¬í•œ ë¬¸ì œë¥¼ í•´ê²°í•˜ì—¬ ê°€ë…ì„±ì„ ë†’ì¸ë‹¤.
ë‘ë²ˆì§¸ ë¬¸ì œëŠ” callbackìœ¼ë¡œ error handlingì´ ì–´ë µë‹¤ëŠ” ê²ƒì´ë‹¤. PromiseëŠ” Promise chainingì„ ì´ìš©í•´ error handlingì„ í•œë‹¤.
PromiseëŠ” ë°˜ë³µì ì¸ ì—°ì‚°ì€ í•  ìˆ˜ ì—†ë‹¤. ëŒ€ì‹  single ì—°ì‚°ì´ ê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì— setTimeoutê³¼ XMLHttpRequestì—ì„œëŠ” loadë¥¼ ëŒ€ì²´í•´ë³¼ ê²ƒì´ë‹¤.
13.2.1 Using Promise
Promise-returning utility function:
getJSON(url).then(jsonData => {
});
getJSON ë‚´ë¶€ì—ì„œ callbackì„ í˜¸ì¶œí•˜ëŠ”ê²Œ ì•„ë‹ˆë¼ thenìœ¼ë¡œ ë„˜ê²¨ì¤€ë‹¤. ë§Œì•½ promise objectì— ì—¬ëŸ¬ë²ˆ thenì„ í˜¸ì¶œí•œë‹¤ë©´ ê°ê°ì˜ functionì€ promise computationì´ ëë‚ ë•Œ í˜¸ì¶œëœë‹¤.
function you pass to then() is asynchronously.
Handling errors with Promise
=>ë¹„ë™ê¸°ì—ì„œ errorë¥¼ handlingí•˜ê¸° ìœ„í•´ì„œ rebust codeê°€ ì¨ì ¸ìˆì–´ì•¼ í•œë‹¤.
Promiseì—ì„œ thenì— ë‘ë²ˆì§¸ functionì„ ì „ë‹¬í•¨ìœ¼ë¡œì¨ error handlingì„ í•  ìˆ˜ ìˆë‹¤.
getJSON("/api/user/profile").then(displayUserProfile,handleProfileError)
ê¸°ì¡´ computationì´ Promise objectê°€ return ëœ ë‹¤ìŒ ìˆ˜í–‰ë˜ê¸° ë•Œë¬¸ì— computationì—ì„œ valueë¥¼ return í•˜ë˜ê°€ í˜¹ì€errorë¥¼ throwí•˜ê³  catchí• ìˆ˜ ì—†ë‹¤. Promise-based asynchronous computationì—ì„œëŠ” exceptionì„ ë‘ë²ˆì§¸ functionìœ¼ë¡œ ì „ë‹¬í•œë‹¤. ê·¸ëŸ¬ë‚˜ ë§Œì•½ getJSONì´ ì•„ë‹Œ displayUserProfileì—ì„œ ì—ëŸ¬ê°€ ë‚ ë•Œ handlingí•  ìˆ˜ ì—†ë‹¤. ì´ë¥¼ ë” ì‰½ê²Œ í•´ê²°í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì´ ì•„ë˜ì™€ ê°™ì´ catchë¥¼ ì“°ëŠ” ê²ƒì´ë‹¤.
getJSON("/api/user/profile").then(displayUserProfile).catch(handleProfileError)
catchëŠ” getJSONì˜ exceptionê³¼ deisplayUserProfileì˜ exception ëª¨ë‘ passedëœë‹¤.
13.2.2 Chaining Promises
callbackì²˜ëŸ¼ nestedí•  í•„ìš”ì—†ì´ chainingì„ í•´ì„œ ì“¸ ìˆ˜ ìˆë‹¤.
fetch(docimentURL)
  .then(response => response.json())
  .then(document => {return render(document);})
  .then(rendered => {cacheInDatabase(rendered);})
  .catch(error => handle(error)) 
ìœ„ì™€ ê°™ì´ XMLHttpRequestë¥¼ ì“¸ ìˆ˜ ìˆë‹¤. fetch()ë¥¼ í†µí•´ URLì„ ì „ë‹¬í•˜ê³  Promiseë¥¼ ë°˜í™˜í•œë‹¤. ì‹¬ì§€ì–´ fetchë¥¼ í†µí•´ text()ì™€ json() methodë¥¼ ì“¸ ìˆ˜ ìˆë‹¤. ê·¸ëŸ¬ë‚˜ fetch()ê°€ fulfilledë˜ì–´ë„ responseì˜ bodyê°€ ì•„ì§ ë„ì°©í•˜ì§€ ì•Šì•„ì„œ ì“¸ ìˆ˜ ì—†ì„ ìˆ˜ ìˆëŠ”ë° ì´ë¥¼ ìœ„í•´ response.json()ì„ ì”€ìœ¼ë¡œì¨ í•´ê²°í•  ìˆ˜ ìˆë‹¤.
fetch("/api/user/profile")
  .then(response => {return response.json();})
  .then(profile => {displayUserProfile(profile);});
ë‹¤ìŒê³¼ ê°™ì´ .then().then()ìœ¼ë¡œ methodê°€ ë‘ê°œ ì´ìƒ ìˆëŠ” ê²ƒì„ method chainì´ë¼ê³  ë¶€ë¥¸ë‹¤. ê°ê°ì˜ then()ì€ ìƒˆë¡œìš´ Promise objectë¥¼ returní•œë‹¤.then()ì´ ì™„ë£Œë˜ê¸° ì „ê¹Œì§€ new Promise objectëŠ” fulfilledë˜ì§€ ì•ŠëŠ”ë‹¤.
fetch -> theurl -> http status,header â†’ fulfill promise1 â†’ callback1 â†’ task2 begin â†’ promise 2 â€¦
13.2.3 Resolving Promise
ìœ„ì˜ ì½”ë“œì—ì„œ promiseë“¤ì„ ë°˜í™˜í–ˆëŠ”ë° ë§ˆì§€ë§‰ìœ¼ë¡œ promiseê°€ í•œë²ˆë” ë°˜í™˜ëœë‹¤. ê·¸ë¦¬ê³  ì´ê²ƒì€ promiseê°€ reslovedë˜ì–´ì•¼ í•œë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤.
c: callback, p:promise, v:value
c â†’ then â†’ p â†’ c â†’ v â†’ p
when promise call callback, callback functionì´ ê³„ì‚°ì„ í•˜ê³  vë¥¼ ë°˜í™˜í•œë‹¤.
ì´ vê°€ non-promiseë¼ë©´ p is fulfilled
vê°€ promiseë¼ë©´ p is resolved not yet fulfilled â†’ can not settle until v settle
v fulfilled â†’ p fulfilled
v rejected â†’ p rejected
so, resolved means, promise associated with another promise
13.2.4 More on Promises and Errors
ì•ìœ¼ë¡œ thenê³¼ catchë¥¼ ì“°ë©´ì„œ error handlingì— ì£¼ì˜ë¥¼ ê¸°ìš¸ì—¬ì•¼ í•œë‹¤.
The catch and finally methods
p.then(null, c )ì™€ p.catch(c) ëŠ” ë™ì¼í•˜ë‹¤. ê·¸ëŸ¬ë‚˜ catchê°€ ë” ì„ í˜¸ë˜ëŠ”ë° try catchì™€ ë¹„ìŠ·í•˜ê³  ë¹„ë™ê¸°ê°€ ê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì´ë‹¤. ë¬´ì–¸ê°€ ë¬¸ì œê°€ ë°œìƒí–ˆì„ë•Œ catchê¹Œì§€ ë„ë‹¬í•˜ê¸° ìœ„í•´ chainì„ íƒ€ê³  ë‚´ë ¤ê°€ëŠ” ê²ƒì„ trickling down the chainì´ë¼ê³  í•œë‹¤.
finally()ëŠ” try catch finally êµ¬ë¬¸ê³¼ ë¹„ìŠ·í•œ ì—­í• ì„ í•œë‹¤.Promiseê°€ fulfilledë˜ê±°ë‚˜ rejectë˜ê±°ë‚˜ callbackì€ ê·¸ëŸ¬í•œ ì •ë³´ë¥¼ ë³´ì—¬ì£¼ì§€ ì•ŠëŠ”ë‹¤. ì •ë³´ëŠ” ì•Œìˆ˜ì—†ì§€ë§Œ clean upì„ í•˜ê³  ì‹¶ì„ë•Œ(ì—´ì—ˆë˜ íŒŒì¼ì„ ë‹«ëŠ”ë‹¤ë˜ê°€) .finally()ë¥¼ ì“¸ ìˆ˜ ìˆë‹¤.
If finally() callback throws an exception, promise return by finally() will reject with that value.
ë§Œì•½ .catch()ë¥¼ chainì˜ ë§ˆì§€ë§‰ì—ë§Œ ë„£ëŠ”ë‹¤ë©´ recoveryê°€ ê°€ëŠ¥í•œ errorë„ ëŒ€ì‘í•˜ì§€ ëª»í•˜ê³  ê·¸ëŒ€ë¡œ ì¢…ë£Œë  ê²ƒì´ë‹¤. (ì˜ˆë¥¼ ë“¤ì–´ urlì—ì„œ í˜ì´ì§€ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆì„ë•Œ recoveryë  ìˆ˜ ìˆìŒì—ë„ ê·¸ëŒ€ë¡œ í”„ë¡œê·¸ë¨ì´ ì¢…ë£Œë  ê²ƒì´ë‹¤.) ê·¸ëŸ¬ë¯€ë¡œ ë§Œì•½ ë‹¤ë¥¸ chainì´ ê·¸ëŒ€ë¡œ ì‹¤í–‰ë˜ì–´ì•¼ í•œë‹¤ë©´ .catch()ë¥¼ chain ì¤‘ê°„ì—ë„ ì¶”ê°€í•˜ëŠ” ê²ƒì´ ì¢‹ì€ ë°©ë²•ì´ ëœë‹¤.
startAsyncOperation()
  .then(doStageTwo)
  .catch(recoverFromStageTwoError)
  .then(doStageThree)
  .then(doStageFour)
  .catch(logStageThreeAndFourErrors)
ë§Œì•½ doStageTwoê°€ ì œëŒ€ë¡œ ì‹¤í–‰ëœë‹¤ë©´ ì¤‘ê°„ì˜ catchëŠ” skipë  ê²ƒì´ë‹¤.
ë§Œì•½ doStageTwoì—ì„œ ë¬¸ì œê°€ ë°œìƒí–ˆë‹¤ë©´ recoverFromStageTwoError ì—ì„œ errorë¥¼ handlingí•˜ê³  ê·¸ ê²°ê³¼ë¥¼ doStageTreeë¡œ ë„˜ê¸´ë‹¤.
13.2.5 Promises in Parallel
ì—¬ëŸ¬ ë¹„ë™ê¸° ì‘ì—…ì„ ë³‘ë ¬ë¡œ ì‹¤í–‰í•˜ë ¤ í• ë•Œ Promise.all()ì„ ì‚¬ìš©í•œë‹¤. inputì€ array of Promise object, outputì€ promiseì´ë‹¤. ë§Œì•½ í•˜ë‚˜ì˜ promiseë¼ë„ rejectë˜ë©´ returnë˜ëŠ” promiseëŠ” rejectëœë‹¤.
array elementëŠ” non-promiseì¼ ìˆ˜ë„ ìˆëŠ”ë° ì´ë•ŒëŠ” ì´ë¯¸ fulfilled promiseë¡œ ì—¬ê²¨ì§„ë‹¤.
Unlike Promise.all(), Promise.allsettled() never rejects the returned Promise, and it does not fulfill that Promise until all of the input Promise settled
13.2.6 Making Promise
Promise relied on hypothetical Promise-returning functions getJSON() and wait()
-Promise based on other Promise :
ì´ë¯¸ ë§Œë“¤ì–´ì§„ Promiseì— thenì„ ë¶™ì´ë©´ ìƒˆë¡œìš´ Promiseë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤.
ì˜ˆë¥¼ ë“¤ì–´ ì´ë¯¸ fetch()ë¼ëŠ” Promiseê°€ ìˆë‹¤ë©´ ë‹¤ìŒê³¼ ê°™ì´ ìƒˆë¡œìš´ Promiseë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤.
function getJSON(url){
  return fetch(url).then(response => response.json());
}
(ì‚¬ì‹¤ ì € ì½”ë“œëŠ” trivialí•œë°, ì™œëƒë©´ ì´ë¯¸ fetchì— json() methodê°€ ì´ë¯¸ ë“¤ì–´ìˆê¸° ë•Œë¬¸ì´ë‹¤.)
-Promise based on synchronous values:
ê°„í˜¹ ê·¸ ë™ì‘ì´ í•„ìš”í•˜ì§€ ì•Šë”ë¼ë„ Promise-based APIë¥¼ í†µí•´ Promiseë¥¼ ìƒì„±í•´ì•¼ í•œë‹¤.
ë³´í†µì€ Promise.resolve()ì™€ Promise.reject()ê°€ ê·¸ ì—­í• ì„ í•œë‹¤.
Promise.resolve() takes value as single argument and returns a Promise that will immediately be fulfilled to that value.
Promise.reject() takes single argument and returns a Promise that will be rejected with that value as the reason.
Itâ€™s fairly common to have synchronous special cases within asynchronous function, and you can handle these special cases with Promise.resolve() and Promise.reject()
for example, error condition can be handle by returning a Promise created with Promise.reject()
-Promise from scratch:
case : canâ€™t use Promise-returning function as start-point
=>use the Promise() constructor to create new Promise object that you have complete control over.
Promise() â† function as only argument, function(reslove,reject) {return new Promise}, does not have to be asynchronous
function wait(duration){
  return new Promise((resolve,reject) => {
    if(duration < 0){
      reject(new Error("Time travel not yet implemented"));
    }
    setTimeout(resolve,duration);
  });
 }
13.2.7 Promises in Sequence
Promise.all()ì„ ì´ìš©í•˜ë©´ ë³‘ë ¬ì ìœ¼ë¡œ ìˆ˜í–‰í•  ìˆ˜ ìˆì§€ë§Œ ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰í•˜ëŠ” ê²ƒì€ ì–´ë µë‹¤.
ì˜ˆë¥¼ ë“¤ì–´ arrayì— urlë“¤ì„ ë„£ê³  ëª¨ë‘ fetch()í• ë ¤ í• ë•Œ, ê¸¸ì´ê°€ arbitraryí•˜ê³  unknown contextì´ê¸° ë•Œë¬¸ì— ë¯¸ë¦¬ Promise chainì„ ì“¸ ìˆ˜ ì—†ë‹¤. ê·¸ëŸ¬ë¯€ë¡œ dynamicallyí•˜ê²Œ ë§Œë“¤ì–´ì•¼í•œë‹¤.
Promiseë¥¼ ë¯¸ë¦¬ ë§Œë“¤ê³  ê·¸ ë’¤ì— chainì„ ë¶™ì¸ë‹¤.
ë˜ë‹¤ë¥¸ ì ‘ê·¼ë²•ìœ¼ë¡œëŠ” Promiseë¥¼ ë¯¸ë¦¬ ë§Œë“¤ê³  ë’¤ë¡œ chainì„ ë¶™ì´ëŠ” ê²Œ ì•„ë‹Œ callback for each Promise.
create and return the next Promise like matryoshka
code can return first Promise.
ğŸ¦‘async and wait
Promise-based, asynchronous codeë¥¼ synchronousí•˜ê²Œ ë³´ì´ê²Œ í•œë‹¤.
Hide the Promise as, easy to read
13.3.1 await Expressions
takes Promise return value or thrown exception
await promise ëŠ” ì£¼ì–´ì§„ promiseê°€ ì˜¬ë•Œê¹Œì§€ waití•œë‹¤.
ì£¼ì–´ì§„ promiseëŠ” fulfilled valueë‚˜ rejection valueë¥¼ returní•œë‹¤.
ê·¸ëŸ¬ë‚˜ awaitì´ codeë¥¼ synchronousí•˜ê²Œ blockí•˜ê±°ë‚˜ í•˜ì§„ ì•ŠëŠ”ë‹¤.
13.3.2 async Functions
await keywordëŠ” aync kaywordë¡œ declaredëœ functionì—ë§Œ ì“¸ ìˆ˜ ìˆë‹¤.
async function getHighScore(){
  let response = await fetch("/api/user/profile");
  let profile = await ewsponse.json();
  return profile.highScore;
}
asyncì„ ì„ ì–¸í•˜ëŠ” ê²ƒì€ ì‹¬ì§€ì–´ codeê°€ Promise related codeê°€ ì•„ë‹ˆë”ë¼ë„ Promiseë¥¼ ë°˜í™˜í•´ì¤€ë‹¤. ë§Œì•½ return valueê°€ ìˆë‹¤ë©´ functionì€ valueë¥¼ resolveí•´ì¤„ê²ƒì´ê³  exceptionì´ throwëœë‹¤ë©´ returnê°’ì€ rejectë ê²ƒì´ë‹¤.
getHighScore functionì€ async keywardë¥¼ ì¼ê¸°ë•Œë¬¸ì— awaitì„ í†µí•´ ê°€ì ¸ì˜¬ ìˆ˜ ìˆë‹¤. (return ê°’ì´ Promise)
displayHighScore(await getHighScore());
13.3.3 Awaiting Multiple Promise
ë§Œì•½ url1ê³¼ url2ë¥¼ ë™ì‹œì— fetch()í•˜ë ¤ í• ë•Œ
async function getJSON(url){
  let response = await fetch(url)
  let body = await response.json();
  return body
}

let value1 = await getJSON(url1);
let value2 = await getJSON(url2);
ë¡œ ì½”ë“œë¥¼ ì“°ë©´ value2ëŠ” url1ì˜ fetchê°€ ëë‚ ë•Œê¹Œì§€ ê°€ì ¸ì˜¤ì§€ ëª» í•œë‹¤.
ë‘ urlì„ ë™ì‹œì— ê°€ì ¸ì˜¤ê¸° ìœ„í•´ì„œëŠ” Promise.all()ì„ ì¨ì•¼í•œë‹¤.
let [value1,value2] = await Promise.all([getJSON(url1),getJSON(url2)])
ğŸ¦‘ Asynchronous Iteration
ì´ì „ì— ì–¸ê¸‰ë˜ì—ˆë“¯ ë°˜ë³µì ìœ¼ë¡œ eventë¥¼ ë¶€ë¥´ê¸° ìœ„í•´ì„œëŠ” setInterval()ì„ ì¨ì•¼í–ˆë‹¤. ê·¸ëŸ¬ë‚˜ PromiseëŠ” ë¹„ë™ê¸° eventë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰ì‹œí‚¬ ìˆ˜ ì—†ê¸°ë•Œë¬¸ì— ì´ ìƒí™©ì—ì„œ async, awaitëŠ” ì“¸ìˆ˜ì—†ë‹¤.
13.4.1 The for/await Loop
Node 12 makes its readable streams asynchronously iterable
const fs = require("fs");

async function parseFile(filename){
  let stream = fs.createReadStream(filename,{encoding:"utf-8"})
  for await (let chunk of stream){
    parseChunk(chunk);
  }
}
for/await loop Promise-based.
asynchronous iteratorê°€ Promiseë¥¼ ìƒì„±í•˜ê³  for/awaitì´ promiseê°€ fulfill ë ë•Œê¹Œì§€ ê¸°ë‹¤ë¦°ë‹¤. fulfillëœ valueë¥¼ loop valueë¡œ ë„˜ê¸°ê³  loop bodyë¥¼ ì‹¤í–‰ì‹œí‚¨ë‹¤. ê·¸ë¦¬ê³  asynchronous iteratorê°€ ìƒˆë¡œìš´ Promiseë¥¼ ë§Œë“¤ê³  ìœ„ì˜ ê³¼ì •ì„ ë°˜ë³µí•œë‹¤.
13.4.2 Asynchronous Iterator
iterable objectëŠ” for/of loopì—ì„œ ì“°ì¼ ìˆ˜ ìˆë‹¤. ê·¸ë¦¬ê³  Symbol.Iterator ì´ë¼ëŠ” methodë¡œ ì •ì˜ë˜ì–´ ìˆë‹¤.
Symbol.Iteratorì€ iterator objectë¥¼ returní•œë‹¤. ë˜ iterable objectì—ëŠ” next() methodê°€ ìˆëŠ”ë°, ì´ê±¸ë¡œ valueë¥¼ ë°˜ë³µì ìœ¼ë¡œ ë°›ì•„ì˜¬ ìˆ˜ ìˆë‹¤.
Asynchronous iteratorì€ ê±°ì˜ ë¹„ìŠ·í•˜ì§€ë§Œ ë‘ê°€ì§€ê°€ ë‹¤ë¥´ë‹¤.
1. implements a method with the symbolic name Symbol.asyncIterator instead of Symbol.iterator
2. next() method of an asynchronous iterator return a Promise
13.4.3 Asynchronous Generators
asynchronous iteratorë¥¼ ì“°ëŠ” ê°€ì¥ ì‰¬ìš´ ë°©ë²•ì€ asyncë¼ê³  ëª…ì‹œí•œ generatorë¥¼ ì“°ëŠ” ê²ƒì´ë‹¤.
awaitì™€ yieldë¥¼ ì“¸ ìˆ˜ ìˆì§€ë§Œ yieldí•œ valueëŠ” Promiseë¡œ ìë™ìœ¼ë¡œ ê°ì‹¸ì§„ë‹¤.
function elapsedTime(ms){
  return new Promise(resolve => setTimeout(resolve,ms))
 }
 async function* clock(interval, max = Infinity){
  for(let count =1; count <= max; count++){
    await elapsedTime(interval);
    yield count;
  }
 }
 async function test(){
  for await(let tick of clock(300,100)){
    console.log(tick);
  }
 }
13.4.4 Implementing Asynchronous Iterators
it is also possible to implement async generators directly by defining an object witn a Symbol.asyncIterator() method that return object with next() method that returns a Promise that resolves to an iterator result object
function clock(interval max = Infinity){
  function until(time){
    return new Promise(resolve => setTimeout(resolve,time - Date.now()))
  }
  return {
    startTime : Date.now(),
    count:1,
    async next(){
      if(this.count > max){
        return {done : true}
      }
      let targetTime = this.startTime + this.count + * interval;
      await until(targetTime)
      return {value : this.count++}
    },
    [Symbol.asyncIterator](){return this;}
  }
}
